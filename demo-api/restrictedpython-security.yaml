name: restrictedpython_security_validation
path: snippets/
headers:
  Authorization: Token ${token}
requests:
  # Test 1: Allowed modules should work
  - name: test_allowed_modules
    method: post
    body:
      title: "Allowed Modules Test"
      code: "# Testing allowed modules"
      language: "python"
      # Test all allowed modules from ALLOWED_MODULES
      datetime_now: ${{ datetime.datetime.now().isoformat() }}
      math_sqrt: ${{ math.sqrt(16) }}
      random_int: ${{ random.randint(1, 10) }}
      regex_match: ${{ bool(re.match("a", "abc")) }}
      time_now: ${{ time.time() }}
      uuid_generated: ${{ str(uuid.uuid4()) }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: allowed_modules_work
        assert: ${{ response.json()["math_sqrt"] == 4.0 }}
      - name: datetime_module_works
        assert: ${{ len(response.json()["datetime_now"]) > 10 }}
      - name: random_in_range
        assert: ${{ 1 <= response.json()["random_int"] <= 10 }}
      - name: regex_works
        assert: ${{ response.json()["regex_match"] == True }}
      - name: time_is_numeric
        assert: ${{ isinstance(response.json()["time_now"], (int, float)) }}
      - name: uuid_is_string
        assert: ${{ isinstance(response.json()["uuid_generated"], str) }}

  # Test 2: Unicode handling
  - name: test_unicode_handling  
    method: post
    body:
      title: "Unicode Test"
      code: "# Testing unicode"
      language: "python"
      # Unicode string operations
      reversed_unicode: ${{ "áéíóú"[::-1] }}
      unicode_length: ${{ len("áéíóú") }}
      unicode_upper: ${{ "hello ñoño".upper() }}
      unicode_title: ${{ "josé maría".title() }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: unicode_reverse_works
        assert: ${{ response.json()["reversed_unicode"] == "úóíéá" }}
      - name: unicode_length_correct
        assert: ${{ response.json()["unicode_length"] == 5 }}
      - name: unicode_upper_works
        assert: ${{ "ÑOÑO" in response.json()["unicode_upper"] }}

  # Test 3: Isolation between requests
  - name: test_isolation_first
    method: post
    body:
      title: "Isolation Test 1"
      code: "# First isolation test"
      language: "python"
      # These should be isolated from each other
      string_length_a: ${{ len("a") }}
      test_value: ${{ 42 }}
    vars:
      first_result: ${{ response.json()["string_length_a"] }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: first_length_correct
        assert: ${{ response.json()["string_length_a"] == 1 }}

  - name: test_isolation_second
    method: post
    body:
      title: "Isolation Test 2"
      code: "# Second isolation test"
      language: "python"
      # Should not have access to previous execution state
      string_length_bb: ${{ len("bb") }}
      different_value: ${{ 84 }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: second_length_correct
        assert: ${{ response.json()["string_length_bb"] == 2 }}
      - name: isolation_verified
        assert: ${{ response.json()["string_length_bb"] != first_result }}

  # Test 4: Complex safe expressions
  - name: test_complex_safe_expressions
    method: post
    body:
      title: "Complex Safe Expressions"
      code: "# Complex expressions test"
      language: "python"
      # Test complex but safe operations
      list_comprehension: ${{ [x * 2 for x in range(1, 6)] }}
      nested_dict: ${{ {"data": {"nested": {"value": 123}}} }}
      string_operations: ${{ "hello world".replace("world", "RestrictedPython").title() }}
      math_combinations: ${{ math.ceil(math.sqrt(math.pow(4, 2))) }}
      datetime_arithmetic: ${{ (datetime.datetime.now() + datetime.timedelta(days=1)).strftime('%Y-%m-%d') }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: list_comprehension_works
        assert: ${{ response.json()["list_comprehension"] == [2, 4, 6, 8, 10] }}
      - name: nested_dict_access_works
        assert: ${{ response.json()["nested_dict"]["data"]["nested"]["value"] == 123 }}
      - name: string_ops_work
        assert: ${{ response.json()["string_operations"] == "Hello Restrictedpython" }}
      - name: math_combinations_work
        assert: ${{ response.json()["math_combinations"] == 4 }}

  # Test 5: Edge cases and boundary conditions
  - name: test_edge_cases
    method: post
    body:
      title: "Edge Cases Test"
      code: "# Edge cases"
      language: "python" 
      # Test edge cases that should work safely
      empty_string_len: ${{ len("") }}
      zero_math: ${{ math.sqrt(0) }}
      negative_abs: ${{ abs(-42) }}
      boolean_operations: ${{ True and False or True }}
      none_check: ${{ None is None }}
      type_checking: ${{ isinstance([], list) }}
    tests:
      - name: status_code_is_201
        assert: ${{ response.status_code == 201 }}
      - name: empty_string_len_zero
        assert: ${{ response.json()["empty_string_len"] == 0 }}
      - name: zero_sqrt_works
        assert: ${{ response.json()["zero_math"] == 0.0 }}
      - name: abs_works
        assert: ${{ response.json()["negative_abs"] == 42 }}
      - name: boolean_logic_works
        assert: ${{ response.json()["boolean_operations"] == True }}
      - name: none_check_works
        assert: ${{ response.json()["none_check"] == True }}
      - name: type_check_works
        assert: ${{ response.json()["type_checking"] == True }}